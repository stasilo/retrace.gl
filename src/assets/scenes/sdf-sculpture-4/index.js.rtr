const randomPointsOnCircle = (r, n) => {
    return range(0, n).map(v => {
        const theta = random(Math.PI*2);

        return [
            r * Math.cos(theta),
            r * Math.sin(theta)
        ];
    });
};

const createLineIntervals = () =>
    range(3, 13)
        .map(y => {
            const points = randomPointsOnCircle(2 + parseInt(random(3)), 2)
                .map(([x, z], i)  => {
                    return {
                        x,
                        y: y + i + random(3),
                        z
                    };
                });
            return points;
        })
        .map(([start, end]) => {
            return sdfLine({
                start,
                end,
                thickness: 0.2,// + random(0.4),
                material: 'floor-white'
            });
        });

scene({
    initialRandomSeed: 41294,
    rendererSettings: {
        realtimeHitDepth: 2,
        hitDepth: 4,
        tMax: 5000,
        maxSphereTracingSteps: 255,
        resolution: 0.45,
        renderMode: 'sdf'
    },
    sdfExportSettings: {
        resolution: 400,
        minCoords: {
            x: -10, y: 0, z: -10,
        },
        maxCoords: {
            x: 20, y: 20, z: 20
        }
    },
    background: ['#000', '#010101'],
    camera: {
        lookFrom: {x: 10.636, y: 7.673, z: -33.771},
        lookAt: {x: 9.305, y: 8.274, z: -29.494},
        vfov: 45,
        aperture: 1e-8,
        velocity: 2
    },
    geometries: [
        sdf(
            // opUnionRound({radius: 1.8, colorBlendAmount: 0.3},
            //     ...createLineIntervals(),
            //     ...createLineIntervals(),
            //     ...createLineIntervals(),
            // )
            opUnionRound({radius: 1.3, colorBlendAmount: 0.3},
                ...createLineIntervals(),
                ...createLineIntervals(),
                ...createLineIntervals(),
                ...createLineIntervals()
            )
            |> opIntersect(#,
                sdfCylinder({
                    displacement: 'noise',
                    position: {x: 0, y: 8, z: 0},
                    radius: 3.7,
                    height: 8
                })
            )
        ),
        sdf(
            sdfCylinder({
                position: {x: 0, y: 4, z: 0},
                radius: 5,
                height: 1
            })
        ),
        plane({
            material: 'floor-white',
            texture: {
                name: 'check',
                uvScale: 20
            },
            scale: 1000,
            position: {
                x: 0,
                y: 0,
                z: 0
            },
        }),
        plane({
            material: 'ceil-light',
            scale: 30,
            position: {
                x: 0,
                y: 80.0,
                z: 0
            },
        })
    ],
    displacements: [
        {
            name: 'noise',
            src: `
                float offset = ${glslFloat(random(100))};
                // float d = sin(1.*(p.x+offset)) * sin(1.*(p.y+offset)) * sin(1.*(p.z+offset));
                float d = snoise((p+offset)*0.25);
                dDist = -d*0.7;
            `
        }
    ],
    textures: [
        texture({
            name: 'check',
            src: `
                float s = sin(50.*uv.x)*sin(50.*uv.y);
                if(s < 0.) {
                    tColor = vec4(${normedColorStr('#aaaaaa')}, 1.0);
                } else {
                    tColor = vec4(0.3, 0.0, 0.0, 1.);
                }
            `
        })
    ],
    materials: [
        lambertMaterial({
            name: `floor-white`,
            color: '#ffffff',
            albedo: [0.8, 0.8, 0.8]
        }),
        emissiveMaterial({
            name: `ceil-light`,
            color: '#ffffff',
            intensity: 10
        })
    ]
});
